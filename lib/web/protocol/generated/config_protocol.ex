# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule ConfigProtocol do

  defmodule Config do

    @enforce_keys [:web, :db, :ldap, :access, :bamboo, :hrvey, :junipeer, :visma]
    defstruct [web: nil, db: nil, ldap: nil, access: nil, bamboo: nil, hrvey: nil, junipeer: nil, visma: nil]

    @type t :: %Config{web: ConfigProtocol.Web.t(), db: ConfigProtocol.Db.t(), ldap: ConfigProtocol.Ldap.t(), access: ConfigProtocol.Access.t(), bamboo: %{atom => ConfigProtocol.Bamboo.t()}, hrvey: ConfigProtocol.Hrvey.t(), junipeer: ConfigProtocol.Junipeer.t(), visma: ConfigProtocol.Visma.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      web = Igor.Json.parse_field!(json, "web", {:custom, ConfigProtocol.Web})
      db = Igor.Json.parse_field!(json, "db", {:custom, ConfigProtocol.Db})
      ldap = Igor.Json.parse_field!(json, "ldap", {:custom, ConfigProtocol.Ldap})
      access = Igor.Json.parse_field!(json, "access", {:custom, ConfigProtocol.Access})
      bamboo = Igor.Json.parse_field!(json, "bamboo", {:map, :atom, {:custom, ConfigProtocol.Bamboo}})
      hrvey = Igor.Json.parse_field!(json, "hrvey", {:custom, ConfigProtocol.Hrvey})
      junipeer = Igor.Json.parse_field!(json, "junipeer", {:custom, ConfigProtocol.Junipeer})
      visma = Igor.Json.parse_field!(json, "visma", {:custom, ConfigProtocol.Visma})
      %Config{
        web: web,
        db: db,
        ldap: ldap,
        access: access,
        bamboo: bamboo,
        hrvey: hrvey,
        junipeer: junipeer,
        visma: visma
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        web: web,
        db: db,
        ldap: ldap,
        access: access,
        bamboo: bamboo,
        hrvey: hrvey,
        junipeer: junipeer,
        visma: visma
      } = args
      %{
        "web" => ConfigProtocol.Web.to_json!(web),
        "db" => ConfigProtocol.Db.to_json!(db),
        "ldap" => ConfigProtocol.Ldap.to_json!(ldap),
        "access" => ConfigProtocol.Access.to_json!(access),
        "bamboo" => Igor.Json.pack_value(bamboo, {:map, :atom, {:custom, ConfigProtocol.Bamboo}}),
        "hrvey" => ConfigProtocol.Hrvey.to_json!(hrvey),
        "junipeer" => ConfigProtocol.Junipeer.to_json!(junipeer),
        "visma" => ConfigProtocol.Visma.to_json!(visma)
      }
    end

  end

  defmodule Web do

    @enforce_keys [:cors, :session]
    defstruct [ip: "127.0.0.1", port: 39100, cors: nil, session: nil, api_keys: []]

    @type t :: %Web{ip: String.t(), port: integer, cors: ConfigProtocol.WebCors.t(), session: ConfigProtocol.WebSession.t(), api_keys: [String.t()]}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      ip = Igor.Json.parse_field!(json, "ip", :string, "127.0.0.1")
      port = Igor.Json.parse_field!(json, "port", :int, 39100)
      cors = Igor.Json.parse_field!(json, "cors", {:custom, ConfigProtocol.WebCors})
      session = Igor.Json.parse_field!(json, "session", {:custom, ConfigProtocol.WebSession})
      api_keys = Igor.Json.parse_field!(json, "api_keys", {:list, :string}, [])
      %Web{
        ip: ip,
        port: port,
        cors: cors,
        session: session,
        api_keys: api_keys
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        ip: ip,
        port: port,
        cors: cors,
        session: session,
        api_keys: api_keys
      } = args
      %{
        "ip" => Igor.Json.pack_value(ip, :string),
        "port" => Igor.Json.pack_value(port, :int),
        "cors" => ConfigProtocol.WebCors.to_json!(cors),
        "session" => ConfigProtocol.WebSession.to_json!(session),
        "api_keys" => Igor.Json.pack_value(api_keys, {:list, :string})
      }
    end

  end

  defmodule WebCors do

    @enforce_keys [:fallback_origin, :allowed_origins]
    defstruct [fallback_origin: nil, allowed_origins: nil]

    @type t :: %WebCors{fallback_origin: String.t(), allowed_origins: [String.t()]}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      fallback_origin = Igor.Json.parse_field!(json, "fallback_origin", :string)
      allowed_origins = Igor.Json.parse_field!(json, "allowed_origins", {:list, :string})
      %WebCors{fallback_origin: fallback_origin, allowed_origins: allowed_origins}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{fallback_origin: fallback_origin, allowed_origins: allowed_origins} = args
      %{
        "fallback_origin" => Igor.Json.pack_value(fallback_origin, :string),
        "allowed_origins" => Igor.Json.pack_value(allowed_origins, {:list, :string})
      }
    end

  end

  defmodule WebSession do

    @enforce_keys [:secret, :encryption_salt, :signing_salt]
    defstruct [secret: nil, encryption_salt: nil, signing_salt: nil]

    @type t :: %WebSession{secret: String.t(), encryption_salt: String.t(), signing_salt: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      secret = Igor.Json.parse_field!(json, "secret", :string)
      encryption_salt = Igor.Json.parse_field!(json, "encryption_salt", :string)
      signing_salt = Igor.Json.parse_field!(json, "signing_salt", :string)
      %WebSession{secret: secret, encryption_salt: encryption_salt, signing_salt: signing_salt}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{secret: secret, encryption_salt: encryption_salt, signing_salt: signing_salt} = args
      %{
        "secret" => Igor.Json.pack_value(secret, :string),
        "encryption_salt" => Igor.Json.pack_value(encryption_salt, :string),
        "signing_salt" => Igor.Json.pack_value(signing_salt, :string)
      }
    end

  end

  defmodule Db do

    @enforce_keys [:url]
    defstruct [url: nil]

    @type t :: %Db{url: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      url = Igor.Json.parse_field!(json, "url", :string)
      %Db{url: url}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{url: url} = args
      %{
        "url" => Igor.Json.pack_value(url, :string)
      }
    end

  end

  defmodule Ldap do

    @enforce_keys [:server, :user_dn, :password, :base, :attr]
    defstruct [server: nil, port: 389, ssl: false, user_dn: nil, password: nil, base: nil, attr: nil]

    @type t :: %Ldap{server: String.t(), port: integer, ssl: boolean, user_dn: String.t(), password: String.t(), base: String.t(), attr: ConfigProtocol.LdapAttrs.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      server = Igor.Json.parse_field!(json, "server", :string)
      port = Igor.Json.parse_field!(json, "port", :int, 389)
      ssl = Igor.Json.parse_field!(json, "ssl", :boolean, false)
      user_dn = Igor.Json.parse_field!(json, "user_dn", :string)
      password = Igor.Json.parse_field!(json, "password", :string)
      base = Igor.Json.parse_field!(json, "base", :string)
      attr = Igor.Json.parse_field!(json, "attr", {:custom, ConfigProtocol.LdapAttrs})
      %Ldap{
        server: server,
        port: port,
        ssl: ssl,
        user_dn: user_dn,
        password: password,
        base: base,
        attr: attr
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        server: server,
        port: port,
        ssl: ssl,
        user_dn: user_dn,
        password: password,
        base: base,
        attr: attr
      } = args
      %{
        "server" => Igor.Json.pack_value(server, :string),
        "port" => Igor.Json.pack_value(port, :int),
        "ssl" => Igor.Json.pack_value(ssl, :boolean),
        "user_dn" => Igor.Json.pack_value(user_dn, :string),
        "password" => Igor.Json.pack_value(password, :string),
        "base" => Igor.Json.pack_value(base, :string),
        "attr" => ConfigProtocol.LdapAttrs.to_json!(attr)
      }
    end

  end

  defmodule LdapAttrs do

    defstruct [class: "objectClass", class_value_user: "person", class_value_group: "group", user_id: "sAMAccountName", user_name: "cn", user_email: "mail", user_office: "o", group_name: "cn", group_members: "member"]

    @type t :: %LdapAttrs{class: String.t(), class_value_user: String.t(), class_value_group: String.t(), user_id: String.t(), user_name: String.t(), user_email: String.t(), user_office: String.t(), group_name: String.t(), group_members: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      class = Igor.Json.parse_field!(json, "class", :string, "objectClass")
      class_value_user = Igor.Json.parse_field!(json, "class_value_user", :string, "person")
      class_value_group = Igor.Json.parse_field!(json, "class_value_group", :string, "group")
      user_id = Igor.Json.parse_field!(json, "user_id", :string, "sAMAccountName")
      user_name = Igor.Json.parse_field!(json, "user_name", :string, "cn")
      user_email = Igor.Json.parse_field!(json, "user_email", :string, "mail")
      user_office = Igor.Json.parse_field!(json, "user_office", :string, "o")
      group_name = Igor.Json.parse_field!(json, "group_name", :string, "cn")
      group_members = Igor.Json.parse_field!(json, "group_members", :string, "member")
      %LdapAttrs{
        class: class,
        class_value_user: class_value_user,
        class_value_group: class_value_group,
        user_id: user_id,
        user_name: user_name,
        user_email: user_email,
        user_office: user_office,
        group_name: group_name,
        group_members: group_members
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        class: class,
        class_value_user: class_value_user,
        class_value_group: class_value_group,
        user_id: user_id,
        user_name: user_name,
        user_email: user_email,
        user_office: user_office,
        group_name: group_name,
        group_members: group_members
      } = args
      %{
        "class" => Igor.Json.pack_value(class, :string),
        "class_value_user" => Igor.Json.pack_value(class_value_user, :string),
        "class_value_group" => Igor.Json.pack_value(class_value_group, :string),
        "user_id" => Igor.Json.pack_value(user_id, :string),
        "user_name" => Igor.Json.pack_value(user_name, :string),
        "user_email" => Igor.Json.pack_value(user_email, :string),
        "user_office" => Igor.Json.pack_value(user_office, :string),
        "group_name" => Igor.Json.pack_value(group_name, :string),
        "group_members" => Igor.Json.pack_value(group_members, :string)
      }
    end

  end

  defmodule Access do

    @enforce_keys [:auth_realm, :admin_group]
    defstruct [auth_realm: nil, admin_group: nil, local_admin: false]

    @type t :: %Access{auth_realm: atom, admin_group: String.t(), local_admin: boolean}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      auth_realm = Igor.Json.parse_field!(json, "auth_realm", :atom)
      admin_group = Igor.Json.parse_field!(json, "admin_group", :string)
      local_admin = Igor.Json.parse_field!(json, "local_admin", :boolean, false)
      %Access{auth_realm: auth_realm, admin_group: admin_group, local_admin: local_admin}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{auth_realm: auth_realm, admin_group: admin_group, local_admin: local_admin} = args
      %{
        "auth_realm" => Igor.Json.pack_value(auth_realm, :atom),
        "admin_group" => Igor.Json.pack_value(admin_group, :string),
        "local_admin" => Igor.Json.pack_value(local_admin, :boolean)
      }
    end

  end

  defmodule Bamboo do

    @enforce_keys [:base_url, :company_domain, :api_key]
    defstruct [base_url: nil, company_domain: nil, api_key: nil, timeoffs: %{}]

    @type t :: %Bamboo{base_url: String.t(), company_domain: String.t(), api_key: String.t(), timeoffs: %{String.t() => DbProtocol.TimeOffKind.t()}}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      base_url = Igor.Json.parse_field!(json, "base_url", :string)
      company_domain = Igor.Json.parse_field!(json, "company_domain", :string)
      api_key = Igor.Json.parse_field!(json, "api_key", :string)
      timeoffs = Igor.Json.parse_field!(json, "timeoffs", {:map, :string, {:custom, DbProtocol.TimeOffKind}}, %{})
      %Bamboo{
        base_url: base_url,
        company_domain: company_domain,
        api_key: api_key,
        timeoffs: timeoffs
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        base_url: base_url,
        company_domain: company_domain,
        api_key: api_key,
        timeoffs: timeoffs
      } = args
      %{
        "base_url" => Igor.Json.pack_value(base_url, :string),
        "company_domain" => Igor.Json.pack_value(company_domain, :string),
        "api_key" => Igor.Json.pack_value(api_key, :string),
        "timeoffs" => Igor.Json.pack_value(timeoffs, {:map, :string, {:custom, DbProtocol.TimeOffKind}})
      }
    end

  end

  defmodule Hrvey do

    @enforce_keys [:url, :email, :password]
    defstruct [url: nil, email: nil, password: nil, timeoffs: %{}]

    @type t :: %Hrvey{url: String.t(), email: String.t(), password: String.t(), timeoffs: %{String.t() => DbProtocol.TimeOffKind.t()}}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      url = Igor.Json.parse_field!(json, "url", :string)
      email = Igor.Json.parse_field!(json, "email", :string)
      password = Igor.Json.parse_field!(json, "password", :string)
      timeoffs = Igor.Json.parse_field!(json, "timeoffs", {:map, :string, {:custom, DbProtocol.TimeOffKind}}, %{})
      %Hrvey{
        url: url,
        email: email,
        password: password,
        timeoffs: timeoffs
      }
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{
        url: url,
        email: email,
        password: password,
        timeoffs: timeoffs
      } = args
      %{
        "url" => Igor.Json.pack_value(url, :string),
        "email" => Igor.Json.pack_value(email, :string),
        "password" => Igor.Json.pack_value(password, :string),
        "timeoffs" => Igor.Json.pack_value(timeoffs, {:map, :string, {:custom, DbProtocol.TimeOffKind}})
      }
    end

  end

  defmodule Junipeer do

    @enforce_keys [:url, :username, :password]
    defstruct [url: nil, username: nil, password: nil]

    @type t :: %Junipeer{url: String.t(), username: String.t(), password: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      url = Igor.Json.parse_field!(json, "url", :string)
      username = Igor.Json.parse_field!(json, "username", :string)
      password = Igor.Json.parse_field!(json, "password", :string)
      %Junipeer{url: url, username: username, password: password}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{url: url, username: username, password: password} = args
      %{
        "url" => Igor.Json.pack_value(url, :string),
        "username" => Igor.Json.pack_value(username, :string),
        "password" => Igor.Json.pack_value(password, :string)
      }
    end

  end

  defmodule Visma do

    defstruct [offices: %{}]

    @type t :: %Visma{offices: %{String.t() => ConfigProtocol.VismaOffice.t()}}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      offices = Igor.Json.parse_field!(json, "offices", {:map, :string, {:custom, ConfigProtocol.VismaOffice}}, %{})
      %Visma{offices: offices}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{offices: offices} = args
      %{
        "offices" => Igor.Json.pack_value(offices, {:map, :string, {:custom, ConfigProtocol.VismaOffice}})
      }
    end

  end

  defmodule VismaOffice do

    @enforce_keys [:api_key]
    defstruct [api_key: nil]

    @type t :: %VismaOffice{api_key: String.t()}

    @spec from_json!(Igor.Json.json()) :: t()
    def from_json!(json) do
      api_key = Igor.Json.parse_field!(json, "api_key", :string)
      %VismaOffice{api_key: api_key}
    end

    @spec to_json!(t()) :: Igor.Json.json()
    def to_json!(args) do
      %{api_key: api_key} = args
      %{
        "api_key" => Igor.Json.pack_value(api_key, :string)
      }
    end

  end

end
