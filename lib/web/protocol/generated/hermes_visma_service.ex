# @author Igor compiler
# @doc Compiler version: igorc 2.1.4
# DO NOT EDIT THIS FILE - it is machine generated

defmodule VismaProtocol.HermesVismaService do

  defmodule Report do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        conn = fetch_query_params(conn)
        year = Igor.Json.parse_field!(conn.path_params, "year", :int)
        month = Igor.Json.parse_field!(conn.path_params, "month", :int)
        office_id = Igor.Json.parse_field!(conn.path_params, "office_id", :long)
        omit_ids = Igor.Json.parse_field!(conn.query_params, "omit_ids", {:option, {:list, ",", :long}})
        omit_uids = Igor.Json.parse_field!(conn.query_params, "omit_uids", {:option, {:list, ",", :string}})
        pretty = Igor.Json.parse_field!(conn.query_params, "pretty", {:option, :boolean})
        api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", {:option, :string})
        {conn, year, month, office_id, omit_ids, omit_uids, pretty, api_key}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, year, month, office_id, omit_ids, omit_uids, pretty, api_key} ->
          handle_get(conn, year, month, office_id, omit_ids, omit_uids, pretty, api_key)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, year, month, office_id, omit_ids, omit_uids, pretty, api_key) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesVismaService.Impl.get_monthly_report_for_office", args: [year, month, office_id, omit_ids, omit_uids, pretty, api_key]}, domain: [:rpc])
      {disposition, response_content} = WebProtocol.HermesVismaService.Impl.get_monthly_report_for_office(year, month, office_id, omit_ids, omit_uids, pretty, api_key)
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesVismaService.Impl.get_monthly_report_for_office", result: {disposition, response_content}}, domain: [:rpc])
      body = response_content
      conn
        |> put_resp_content_type("application/json")
        |> put_resp_header("content-disposition", disposition)
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesVismaService.Impl.get_monthly_report_for_office", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesVismaService.Impl.get_monthly_report_for_office", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesVismaService.Impl.get_monthly_report_for_office", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule ReportByRole do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        conn = fetch_query_params(conn)
        year = Igor.Json.parse_field!(conn.path_params, "year", :int)
        month = Igor.Json.parse_field!(conn.path_params, "month", :int)
        office_id = Igor.Json.parse_field!(conn.path_params, "office_id", :long)
        omit_ids = Igor.Json.parse_field!(conn.query_params, "omit_ids", {:option, {:list, ",", :long}})
        omit_uids = Igor.Json.parse_field!(conn.query_params, "omit_uids", {:option, {:list, ",", :string}})
        include_ids = Igor.Json.parse_field!(conn.query_params, "include_ids", {:option, {:list, ",", :long}})
        include_uids = Igor.Json.parse_field!(conn.query_params, "include_uids", {:option, {:list, ",", :string}})
        included_only = Igor.Json.parse_field!(conn.query_params, "included_only", :boolean, false)
        csv = Igor.Json.parse_field!(conn.query_params, "csv", {:option, :boolean})
        {conn, year, month, office_id, omit_ids, omit_uids, include_ids, include_uids, included_only, csv}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, year, month, office_id, omit_ids, omit_uids, include_ids, include_uids, included_only, csv} ->
          handle_get(conn, year, month, office_id, omit_ids, omit_uids, include_ids, include_uids, included_only, csv)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, year, month, office_id, omit_ids, omit_uids, include_ids, include_uids, included_only, csv) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesVismaService.Impl.get_monthly_report_for_office_by_role", args: [year, month, office_id, omit_ids, omit_uids, include_ids, include_uids, included_only, csv, get_session(conn, :api)]}, domain: [:rpc])
      {content_type, disposition, response_content} = WebProtocol.HermesVismaService.Impl.get_monthly_report_for_office_by_role(year, month, office_id, omit_ids, omit_uids, include_ids, include_uids, included_only, csv, get_session(conn, :api))
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesVismaService.Impl.get_monthly_report_for_office_by_role", result: {content_type, disposition, response_content}}, domain: [:rpc])
      body = response_content
      conn
        |> put_resp_content_type(content_type)
        |> put_resp_header("content-disposition", disposition)
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesVismaService.Impl.get_monthly_report_for_office_by_role", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesVismaService.Impl.get_monthly_report_for_office_by_role", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesVismaService.Impl.get_monthly_report_for_office_by_role", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  defmodule TimeOffReport do

    require Logger
    import Plug.Conn

    def init(opts), do: opts

    def call(%{method: method} = conn, _opts), do: handle_method(method, conn)

    defp handle_method("GET", conn) do
      try do
        year = Igor.Json.parse_field!(conn.path_params, "year", :int)
        month = Igor.Json.parse_field!(conn.path_params, "month", :int)
        office_id = Igor.Json.parse_field!(conn.path_params, "office_id", :long)
        api_key = Igor.Json.parse_field!(%{"x-api-key" => List.first(get_req_header(conn, "x-api-key"))}, "x-api-key", :string)
        {conn, year, month, office_id, api_key}
      rescue
        e in Igor.DecodeError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
        e in Igor.Http.BadRequestError ->
          body = Igor.Json.encode!(%{"error" => e.message})
          conn
              |> put_resp_content_type("application/json")
              |> send_resp(400, body)
      else
        {conn, year, month, office_id, api_key} ->
          handle_get(conn, year, month, office_id, api_key)
      end
    end
    defp handle_method(_, conn) do
      conn
        |> put_resp_header("allow", "GET")
        |> send_resp(405, "")
    end

    defp handle_get(conn, year, month, office_id, api_key) do
      Logger.debug("rpc_req", data: %{method: "WebProtocol.HermesVismaService.Impl.get_time_off_monthly_report_for_office", args: [year, month, office_id, api_key]}, domain: [:rpc])
      response_content = WebProtocol.HermesVismaService.Impl.get_time_off_monthly_report_for_office(year, month, office_id, api_key)
      Logger.debug("rpc_res", data: %{method: "WebProtocol.HermesVismaService.Impl.get_time_off_monthly_report_for_office", result: response_content}, domain: [:rpc])
      body = response_content
        |> Igor.Json.pack_value({:custom, VismaProtocol.ExcelTimeOffReport})
        |> Igor.Json.encode!
      conn
        |> put_resp_content_type("application/json")
        |> send_resp(200, body)
    rescue
      e in DataProtocol.ForbiddenError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesVismaService.Impl.get_time_off_monthly_report_for_office", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.ForbiddenError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(403, body)
      e in DataProtocol.NotFoundError ->
        Logger.notice("rpc_exc", data: %{method: "WebProtocol.HermesVismaService.Impl.get_time_off_monthly_report_for_office", exception: e}, domain: [:rpc])
        body = e
          |> Igor.Json.pack_value({:custom, DataProtocol.NotFoundError})
          |> Igor.Json.encode!
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(404, body)
      e ->
        Logger.error("rpc_exc", data: %{method: "WebProtocol.HermesVismaService.Impl.get_time_off_monthly_report_for_office", exception: e, stacktrace: __STACKTRACE__}, domain: [:rpc])
        body = Igor.Json.encode!(%{"error" => inspect(e)})
        conn
          |> put_resp_content_type("application/json")
          |> send_resp(500, body)
    end

  end

  @doc """
  Get Visma monthly report for an office
  """
  @callback get_monthly_report_for_office(integer, integer, integer, [integer] | nil, [String.t()] | nil, boolean | nil, String.t() | nil) :: {String.t(), binary}

  @doc """
  Get Visma monthly report for an office grouped by role
  """
  @callback get_monthly_report_for_office_by_role(integer, integer, integer, [integer] | nil, [String.t()] | nil, [integer] | nil, [String.t()] | nil, boolean, boolean | nil, session :: any()) :: {String.t(), String.t(), binary}

  @doc """
  Get timeoff monthly report for an office
  """
  @callback get_time_off_monthly_report_for_office(integer, integer, integer, String.t()) :: VismaProtocol.ExcelTimeOffReport.t()

end
